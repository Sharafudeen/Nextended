/// <summary>
/// --- AUTO GENERATED CODE (<#= DateTime.Now.ToShortDateString() + " " + DateTime.Now.ToLongTimeString()#>) --- 
/// --- COM Klassen ---
/// </summary>
<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ parameter type="System.String" name="ProjectFolder" #>


<#@ assembly name="System.Core"#>
<#@ assembly name="System.Xml"#>
<#@ assembly name="$(ProjectDir)..\bin\Nextended.Core\netstandard2.1\Nextended.Core.dll" #>
<#@ assembly name="VSLangProj"#>
<#@ assembly name="Microsoft.VisualStudio.Shell.15.0" #>
<#@ assembly name="Microsoft.VisualStudio.Shell.Interop"#>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.CodeDom" #>
<#@ import namespace="Nextended.Core.Attributes" #>
<#@ import namespace="Nextended.Core.Extensions" #>
<#@ import namespace="Nextended.Core.COM" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Runtime.InteropServices" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.Xml.Serialization" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.ComponentModel" #>
<#@ import namespace="Microsoft.CSharp" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#@ import namespace="VSLangProj" #>
<#@ import namespace="Microsoft.VisualStudio.Shell"#>
<#@ import namespace="Microsoft.VisualStudio.Shell.Interop" #>
<#@ include file="ComConversion.t4"#>
<#@ output extension=".Generated.cs"#>
<#
var classesToCreate = GetSourceClassesToBuild(typeof(AutoGenerateComAttribute));
foreach(var ns in GetNamespaces(classesToCreate.Select(c=>c.Item1).ToArray())) { 
	WriteLine(string.Format("using {0};",ns));
}  
BreakLine();
WriteLineFormat("namespace {0}", System.Runtime.Remoting.Messaging.CallContext.LogicalGetData("NamespaceHint") ?? "CP.Server.Embedded.COM.AutoGenerated");
WriteLine("{");
BreakLine();
PushIndent("\t");
	if(createRegions){
		WriteLineFormat("#region GENERATED CLASSES{0}", GetLineBreak());
	}
	WriteComClasses(classesToCreate);
	WriteComIdClass();
	WriteLineFormat("{3}// END CLASS GENERATION - GENERATED {0} CLASSES, {1} INTERFACES and {2} ENUMS{3}", classCount, interfaceCount, enumCount, GetLineBreak());
	if(createRegions){
		WriteLineFormat("#endregion GENERATED CLASSES {0}", GetLineBreak());
	}	
	WriteMappingExtensions(classesToCreate);
PopIndent();
WriteLine("}");
#>
<#+
//////////////////////////////////// SETTINGS ////////////////////////////////////
string comIdClassName = "ComGuids";
string comIdFormat = "Id{0}";
string comIdClassModifier = "internal";
string classModifier = "public";
string interfaceModifier = "public";
bool createRegions = true;
bool createComments = true;
bool generatePartial = true;
/////////////////////////////////END SETTINGS ////////////////////////////////////

int classCount = 0;
int enumCount = 0;
int interfaceCount = 0;

private void WriteComClasses(Tuple<Type, AutoGenerateComAttribute[]>[] classesToCreate){	
	foreach(var ns in classesToCreate) {
		foreach(AutoGenerateComAttribute setting in ns.Item2) {				
		if(createRegions){
			WriteLineFormat("#region COM For {0}{1}", ns.Item1.Name, GetLineBreak());			
		}
		WriteInterface(ns.Item1, setting);
		BreakLine();
		WriteClass(ns.Item1, setting);
		BreakLine();
		if(createRegions){
			WriteLineFormat("#endregion COM For {0}", ns.Item1.Name);
			BreakLine();
		}
	}
	}	
}

private void WriteComIdClass(){	
	classCount ++;
	if(createRegions){
		WriteLineFormat("#region {0}{1}", comIdClassName, GetLineBreak());
	}
	WriteLineFormat("{0} static partial class {1}", comIdClassModifier, comIdClassName);
	WriteLine("{");
	PushIndent("\t");
	foreach(var id in ComIds){
		WriteLineFormat("public const string {0}=\"{1}\";", string.Format(comIdFormat, id.Key), id.Value );
	}
	PopIndent();
	WriteLine("}");	

	if(createRegions){
		WriteLineFormat("#endregion {0}{1}", comIdClassName, GetLineBreak());
	}
}

private void WriteEnum(Type enumType, AutoGenerateComAttribute settings){	
	string className = GetClassName(enumType, settings, false);
	enumCount++;
	if(createComments){
		WriteComment(enumType, className);
	}
	WriteLine("[ComVisible(true)]");
	WriteLineFormat("[Guid({0})]", GetGuid(className));
	WriteLineFormat("{1} enum {0} ",  className, classModifier);
	WriteLine("{");
	PushIndent("\t");
	int dispId = 0;
	var memberInfos = enumType.GetMembers(BindingFlags.Public | BindingFlags.Static);
	foreach (MemberInfo enumMember in memberInfos)
	{		
		var enumMemberName = GetComName(enumMember);

		if(createComments){
			var comment = GetComment(enumMember);
			WriteLineFormat("/// <summary>{0}/// {1}{0}/// </summary>", GetLineBreak(), comment);
		}
		WriteLineFormat("[DispId({0})]", ++dispId);
		WriteLineFormat("{0} = {1}.{2},", enumMemberName, enumType.FullName, enumMember.Name);		
	}     
	PopIndent();
	WriteLine("}");
}

private void WriteClass(Type objectType, AutoGenerateComAttribute settings){	
	if(objectType.IsEnum){
		WriteEnum(objectType, settings);
	}else{
		classCount ++;
		var props = GetTargetProperties(objectType);
		var comListProperties = props.Where(p => IsComlist(p)).ToArray();
		string className = GetClassName(objectType, settings, false);
		if(createRegions){
			WriteLineFormat("#region {0}{1}", className, GetLineBreak());
		}
		if(createComments){
			WriteComment(objectType, className);
		}
		WriteLineFormat("[ComVisible(true)]{0}[Guid({1})]", GetLineBreak(), GetGuid(className));
	
		string parentClass = "";
		var parentClassInfo = GetParentClassInfo(objectType, false);	
		if(parentClassInfo != null){		
			parentClass = string.Format("{0},", parentClassInfo.Item2);		 
		}

		WriteLineFormat("{2} {3} class {1} : {0} I{1}", parentClass, className, classModifier, generatePartial ? "partial" : "");
		WriteLine("{");
		if(comListProperties.Any()){
			PushIndent("\t");
				WriteLineFormat("public {0}()", className);
				WriteLine("{");
				PushIndent("\t");
				foreach(var p in comListProperties) {
					var propertyName = GetComName(p);
					WriteLineFormat("{0} = new {1}();", propertyName, typeof(ComList).FullName);
				}
				PopIndent();
				WriteLine("}");
			PopIndent();
		}
		WriteProperties(props, false, 0, settings);
		WriteLine("}");
		if(createRegions){
			WriteLineFormat("#endregion {0}", className);	
		}
	}
}

private void WriteInterface(Type objectType, AutoGenerateComAttribute settings){	
	if(!objectType.IsEnum){
		interfaceCount++;
		string className = GetClassName(objectType, settings, true);
		int dispStart = 0;
		string parentClass = "";
		var parentClassInfo = GetParentClassInfo(objectType, true);	
		if(parentClassInfo != null){		
			parentClass = string.Format(":{0}", parentClassInfo.Item2);
			dispStart = parentClassInfo.Item1;			
		}	
		if(createRegions){
			WriteLineFormat("#region {0}{1}", className, GetLineBreak());
		}
		if(createComments){
			WriteComment(objectType, className);
		}
		WriteLineFormat("[ComVisible(true)]{0}[Guid({1})]{0}[TypeLibType(TypeLibTypeFlags.FDual | TypeLibTypeFlags.FDispatchable)]", GetLineBreak() ,GetGuid(className));
		WriteLineFormat("{2} {3} interface {0} {1}", className, parentClass, interfaceModifier, generatePartial ? "partial" : "");
		WriteLine("{");
		WriteProperties(GetTargetProperties(objectType), true, dispStart, settings);
		WriteLine("}");
		if(createRegions){
			WriteLineFormat("#endregion {0}", className);	
		}
	}
} 

private T[] GetAttribute<T>(ICustomAttributeProvider t, bool inherit = true) {
	return t.GetCustomAttributes(typeof(AutoGenerateComAttribute), inherit) as T[] ?? new T[0]; 
}

private Tuple<int, string, AutoGenerateComAttribute> GetParentClassInfo(Type objectType, bool forInterface){
	
	var baseTypeSettings = GetAttribute<AutoGenerateComAttribute>(objectType.BaseType).FirstOrDefault();
	if(baseTypeSettings != null){
		int dispStart = 0;
		string parentClass = GetClassName(objectType.BaseType, baseTypeSettings, forInterface);
		
		if(	forInterface){				
			dispStart = GetTargetProperties(objectType.BaseType).Length;
		
		
			var t = objectType.BaseType.BaseType;
			baseTypeSettings = GetAttribute<AutoGenerateComAttribute>(t).FirstOrDefault();
			while(baseTypeSettings != null){
				dispStart += GetTargetProperties(t).Length;
				t = t.BaseType;
				baseTypeSettings = GetAttribute<AutoGenerateComAttribute>(t).FirstOrDefault();
			}
		}
		return Tuple.Create(dispStart, parentClass, baseTypeSettings );		
	}
	return null;
}

private void BreakLine(){
	WriteLine(string.Empty);
}

private string GetLineBreak(){
	return Environment.NewLine;	
} 

private string GetClassName(Type objectType, AutoGenerateComAttribute settings, bool asInterface){
	if(settings != null && !string.IsNullOrEmpty(settings.ComClassName)){
		return string.Format("{1}{0}", settings.ComClassName , asInterface && !objectType.IsEnum ? "I" : string.Empty); 
	}
	var prefix = settings != null ? settings.Prefix : string.Empty;
	var suffix = settings != null ? settings.Suffix : string.Empty;
	string mainClassName = objectType.Name;
	string extras = "";	
	if(settings != null && settings.GenericParameterTypes != null && settings.GenericParameterTypes.Length > 0){
		extras = String.Join("", settings.GenericParameterTypes.Select(type => type.Name));		
	}
	if(mainClassName.IndexOf('`') >= 0){
		mainClassName = mainClassName.Substring(0, mainClassName.IndexOf('`'));
	}
	return string.Format("{3}{0}{1}{4}{2}", prefix, mainClassName , suffix, asInterface && !objectType.IsEnum ? "I" : string.Empty, extras); 
}


private void WriteLineFormat(string s, params object[] args){
	if(args == null || !args.Any()){
		WriteLine(s);
	}
	else{	
		WriteLine(string.Format(s, args));
	}
}

private Type FindEnumType(Type enumType){
	if(enumType.IsEnum){
		return enumType.GetFields(BindingFlags.Public | BindingFlags.Static).Any(info => GetAttribute<XmlEnumAttribute>(info).FirstOrDefault() == null) ? typeof(int) : typeof(string);
	}
	return enumType;
} 

private void WriteProperty(PropertyInfo propertyInfo, bool asInterface, AutoGenerateComAttribute declaringTypeSettings){
	string modifier = asInterface ? string.Empty : "public";
	string getterSetter = "{ get; set; }";
	var comType = GetComType(propertyInfo);	
	var comTypeAttr = GetAttribute<ComPropertySettingAttribute>(propertyInfo).FirstOrDefault();
	
	var typeClassAttribute = GetAttribute<AutoGenerateComAttribute>(propertyInfo.PropertyType).FirstOrDefault();
	
	string propTypeName = (typeClassAttribute != null && (comTypeAttr == null || comTypeAttr.Type == null))
		? GetClassName(propertyInfo.PropertyType, typeClassAttribute, true) 
		: GetTypeAlias(comType);

	if(asInterface) { // ComAliasNameAttribute weiterleiten		
		var comAliasName = GetAttribute<ComAliasNameAttribute>(propertyInfo).FirstOrDefault(); 
		if(comAliasName != null){
			WriteLineFormat(" [ComAliasName(\"{0}\")]", comAliasName.Value);
		}
	}

	var propertyName = GetComName(propertyInfo);
	
	if(propTypeName == propertyInfo.PropertyType.Name && propertyInfo.PropertyType.IsGenericParameter){	   	    
		propTypeName = GetTypeAlias(GetMatchingGenericPropertyType(propertyInfo, declaringTypeSettings));
	}
	WriteLineFormat("{0} {1} {2} {3}", modifier, propTypeName, propertyName, getterSetter);
}
	
private string GetComName(MemberInfo memberInfo)
{	
	var comNameAttr = GetAttribute<ComPropertySettingAttribute>(memberInfo).FirstOrDefault();
	return comNameAttr != null && !string.IsNullOrEmpty(comNameAttr.PropertyName) ? comNameAttr.PropertyName : memberInfo.Name;
}

private Type GetComType(PropertyInfo propertyInfo) {
	var comType = propertyInfo.PropertyType;	
	var comTypeAttribute = GetAttribute<ComPropertySettingAttribute>(propertyInfo).FirstOrDefault();

	if(comTypeAttribute != null && comTypeAttribute.Type != null)
		comType = comTypeAttribute.Type;
	else if(propertyInfo.PropertyType.IsEnum)
		comType = FindEnumType(propertyInfo.PropertyType);
	else if(IsNullable(propertyInfo.PropertyType))
		comType = propertyInfo.PropertyType.GetGenericArguments()[0];
	else if(IsComlist(propertyInfo.PropertyType))
		comType = typeof(IComList);
	else if(propertyInfo.PropertyType.IsBaseId())
		comType = typeof(ComId);

	return comType;
}

private Type GetMatchingGenericPropertyType(Type genericArgType, Type type, AutoGenerateComAttribute autoGenerateAttr){
	if(!genericArgType.IsGenericParameter){
		return genericArgType;
	}
	var prop = type.GetProperties(System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.DeclaredOnly).FirstOrDefault(pi => pi.PropertyType.IsGenericParameter && pi.PropertyType == genericArgType);	
	if(prop == null)
		return genericArgType;
	return GetMatchingGenericPropertyType(prop, autoGenerateAttr );
 }

private Type GetMatchingGenericPropertyType(PropertyInfo propertyInfo, AutoGenerateComAttribute settings ){
	if (propertyInfo.PropertyType.IsGenericParameter && settings != null)
    {	
        Type[] genericArguments = propertyInfo.DeclaringType.GetGenericArguments();
        var indexOf = Array.IndexOf(genericArguments, propertyInfo.PropertyType);
		if(indexOf >= 0 && settings.GenericParameterTypes != null && settings.GenericParameterTypes.Length -1 >= indexOf){
			return settings.GenericParameterTypes[indexOf];
		}
    }	
	return propertyInfo.PropertyType;
}

private bool IsNullable(Type type) {
	return type.IsGenericType && type.GetGenericTypeDefinition() == typeof(Nullable<>);
}

private bool IsComlist(Type type){	
	if(type.IsArray || type.IsGenericType && type.GetInterfaces().Any(ti => ti.IsGenericType && ti.GetGenericTypeDefinition() == typeof(IEnumerable<>)))
		return true; 
	return false; 
}

private bool IsComlist(PropertyInfo info){	
	var attr = GetAttribute<ComPropertySettingAttribute>(info).FirstOrDefault();
	return (attr == null || attr.Type == null ) && IsComlist(info.PropertyType);
}

private void WriteProperties(PropertyInfo[] propertyInfo, bool asInterface, int dispIdStart, AutoGenerateComAttribute declaringTypeSettings){
	PushIndent("\t");
	int dispId = dispIdStart; 
	foreach(var p in propertyInfo) {
		if(createComments){
			var comment = GetComment(p);
			WriteLineFormat(" /// <summary>{0} /// {1}{0} /// </summary>", GetLineBreak(), comment);
		}
		if(asInterface){
			WriteLineFormat(" [DispId({0})]", ++dispId);
		}
		WriteProperty(p, asInterface, declaringTypeSettings);
		WriteLine("");
	}
	PopIndent();
}

private void WriteComment(Type objectType, string className){	
	WriteLineFormat(" /// <summary>{0} /// {2} - {1}{0} /// GENERATED FROM <see cref=\"T:{3}\"/> {0} /// </summary>", GetLineBreak(), GetComment(objectType), className, objectType.FullName);
}

XmlDocument _docuDoc = null;
private string GetComment(Type type, string memberName = ""){
	string docuPath = System.IO.Path.ChangeExtension(type.Assembly.GetName().CodeBase, ".XML")
					  .Replace("file:///", string.Empty);			
	
	if (File.Exists(docuPath) && _docuDoc == null)
	{
		_docuDoc = new XmlDocument();
		_docuDoc.Load(docuPath);	
	}
	if(_docuDoc != null){	
		string path = "T:" + type.FullName;
		if(!string.IsNullOrEmpty(memberName))
			path = "P:" + type.FullName + "." + memberName;

		XmlNode xmlDocuOfMethod = _docuDoc.SelectSingleNode("//member[starts-with(@name, '" + path + "')]");
		if(xmlDocuOfMethod != null) {					
			var str = Regex.Replace(xmlDocuOfMethod.InnerXml, @"\s+", " ");
			var match = Regex.Match(str, "<summary>(.*?)</summary>");
			if(match.Success && match.Groups.Count > 1) {
				return match.Groups[1].Value;
			}
			return str;		
		}
	}
	return string.IsNullOrEmpty(memberName) ? type.Name : memberName;
}

private string GetComment(MemberInfo info){
	return GetComment(info.DeclaringType, info.Name);
}

Dictionary<string, Guid> ComIds = new Dictionary<string, Guid>();

private string GetGuid(string className){	
	if(!ComIds.ContainsKey(className)){
		var guid = className.GetHashCode().ToGuid();
		ComIds.Add(className, guid);
	}
	return string.Format("{0}.{1}", comIdClassName, string.Format(comIdFormat, className));
}
        
private string GetTypeAlias(Type type)
{
    var compiler = new CSharpCodeProvider();
	var alias = compiler.GetTypeOutput(new CodeTypeReference(type));
	if(typeof(System.Attribute).IsAssignableFrom(type) && alias.EndsWith("Attribute")){
		return alias.Substring(0, alias.Length - "Attribute".Length);
	}

    return alias; // == type.FullName ? type.Name : alias; 
}

private Tuple<Type, AutoGenerateComAttribute[]>[] GetSourceClassesToBuild(Type type, Func<Type, bool> predicate = null)
{
	predicate = predicate ?? (t => true);
	return (from sourceType in Assembly.GetAssembly(type).GetTypes().Where(predicate)		
		let attr = GetAttribute<AutoGenerateComAttribute>(sourceType, false)
		where attr != null
		select Tuple.Create(sourceType, attr)).ToArray();
}

private PropertyInfo[] GetTargetProperties(Type targetType) { 
	return GetProperties(targetType)		  
		  .Where(pi => GetAttribute<ComIgnoreAttribute>(pi).FirstOrDefault() == null)
		//.OrderBy(pi => pi.Name)
		.ToArray();
}

private static IEnumerable<PropertyInfo> GetProperties(Type type)
{    	
	PropertyInfo[] allProperties = null;
	var res = type.GetProperties(System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.DeclaredOnly).ToList();

	// TODO: ggf Einschränkungen z.B nur mit Datamember Attribute oder ähnlichem
	var baseType = type.BaseType;
	while (baseType != null && baseType != typeof(object))
	{
		var propertyInfos = baseType.GetProperties(System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.DeclaredOnly);                
		var genericBaseTypeArgs = baseType.GetGenericArguments();
		if (genericBaseTypeArgs.Any())
		{
			if(allProperties == null)
				allProperties = type.GetProperties(System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance);
			res.AddRange(allProperties.Where(info => propertyInfos.Any(propertyInfo => propertyInfo.Name == info.Name) && res.All(ri => ri.Name != info.Name)));
		}
		baseType = baseType.BaseType;
	}

	return res.Distinct();
}

private string[] GetNamespaces(Type[] types) 
{
	return new [] {
		"System", 		
		"System.Runtime.InteropServices",		
		"System.Linq",
		"System.Collections.Generic",
		"System.Reflection",
		"System.Xml.Serialization",
		"CP.Common",
		"CP.Common.Extensions"
	};	 
}


///////////////// EXPERIMENTAL REFLECTION AND DTE METHODS /////////////////////////////////////
/*
Type autoGenerateComAttributeType = null;
private Type FindAutoGenerateComAttributeType(){
	// return typeof (AutoGenerateComAttribute)
	if(autoGenerateComAttributeType == null){
		autoGenerateComAttributeType = GetAllReferencedTypes().First(t => t.FullName.Contains("AutoGenerateComAttribute"));
	}
	return autoGenerateComAttributeType;
}


private DTE GetDTE(){
	var serviceProvider = this.Host as IServiceProvider;
    return serviceProvider.GetService(typeof(EnvDTE.DTE)) as EnvDTE.DTE;
}

private SVsSolution GetSVsSolution(){
	var serviceProvider = this.Host as IServiceProvider;
    return serviceProvider.GetService(typeof(SVsSolution)) as SVsSolution;
}

private Project GetProject()
{
    // Get DTE
    var dte = GetDTE(); 

    // Get ProjectItem representing the template file
    ProjectItem projectItem = dte.Solution.FindProjectItem(this.Host.TemplateFile);

    // Get the Project of the template file
    Project project = projectItem.ContainingProject;

    return project;
}

private HashSet<KeyValuePair<string,string>> GetReferences() {	
	var project = GetProject();
	HashSet<KeyValuePair<string,string>> list = new HashSet<KeyValuePair<string,string>>();
    if (project.Object is VSLangProj.VSProject) {
        VSLangProj.VSProject vsproject = (VSLangProj.VSProject)project.Object;        
        foreach (VSLangProj.Reference reference in vsproject.References) {
			list.Add(new KeyValuePair<string, string>(reference.Identity, reference.Path));
        }        
    } 
	return list;
}

private Type[] GetTypesFromAssembly(string asmName){
    AppDomain curDomain = AppDomain.CurrentDomain;

    curDomain.ReflectionOnlyAssemblyResolve += CurDomain_ReflectionOnlyAssemblyResolve;

    Assembly asm = Assembly.ReflectionOnlyLoadFrom(asmName);
    Type[] types = asm.GetTypes();
	return types;
}

Type[] allReferencedTypes = null;
private Type[] GetAllReferencedTypes(){
  if(allReferencedTypes == null){	
     string path =  GetCPContractDllPath(); // TODO: ggf alle CP Assemblies
	 allReferencedTypes = GetTypesFromAssembly(path);
  }
  return allReferencedTypes; 
}

private Assembly CurDomain_ReflectionOnlyAssemblyResolve(object sender, ResolveEventArgs args)
{
    AssemblyName name = new AssemblyName(args.Name);
    String asmToCheck = Path.GetDirectoryName(args.RequestingAssembly.Location) + "\\" + name.Name + ".dll";

    if (File.Exists(asmToCheck))
    {
        return Assembly.ReflectionOnlyLoadFrom(asmToCheck);
    }

    return Assembly.ReflectionOnlyLoad(args.Name);
}

private string GetCPContractDllPath(){
	return GetReferences().First(p => p.Key.Contains("CP.Contracts")).Value;
}
*/
///////////////// END REFLECTION DTE METHODS ////////////////////////////////////////////////
#>